{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Week 12 documentation\"\nauthor: \"Pan Chen\"\ndate: \"1/19/2018\"\noutput: html_document\n---\n## Load \"week 12 Data.RData\", and we will go from there:\nLet's see what do we have now:\n```{r}\nsetwd('/data/rstudio10/Pan_Stuff/Documentation')\ntmp1<-head(disambReference,1000)\ntmp2<-head(disambintlpatref,1000)\n```\nTheir \"coauthor\" column is another dataset, so each of these dataframe has a dataframe within it\nFlatten them so they could be exported to csv.\n```{r}\ntmp1$coauthor<-sapply(tmp1$coauthor, FUN = function(x) paste(x,collapse = ', ',sep=''))\ntmp2$coauthor<-sapply(tmp2$coauthor, FUN = function(x) paste(x,collapse = ', ',sep=''))\nwrite.csv(tmp1,file = 'data/disambReference_sample.csv')\nwrite.csv(tmp2,file = 'data/disambIntlpatref_sample.csv')\n```\nNow let's work primarily with our exported sample datasets\n```{r}\ndisambReference<-read.csv('data/disambReference_sample.csv',row.names = 1)\ndisambIntlpatref<-read.csv('data/disambIntlpatref_sample.csv',row.names = 1)\n```\nHere's the code for the co-author matching function:\n```{r}\nf <- function(x) {\nb<-sapply(X = x[[8]], FUN = function (X) { grep(X, x[[15]], ignore.case = TRUE, fixed = TRUE, perl=FALSE) }, simplify = \"array\")\n  return (length(unlist(b)))\n}\n```\nHere's an example on how to use this function: the reason it doesn't work with our sample dataset is probably because I have flattened the coauthor columns of both tables...\n\nif it works correctly, match1 would be a table whose rows represent all of the patents and references with the matching Author FName and LName\n\nnummatch column represents the number of the coauthor matches between the (FName, LName) matching reference and patent.\n\n```{r}\nmatch1<-merge(disambReference, disambIntlpatref, by.x = c(\"Fname\",\"Lname\"), by.y = c(\"Fname\",\"Lname\"), all.x = FALSE, all.y = FALSE)\nmatch1$nummatch<-apply(match1, 1, f)\n```\nTODO:\n\nHowever, what we got stuck at the end of the last semester is:\nthis method did not seem to be able to disambiguate the following scenario:\nAssume we have a Reference Table, which has three records\nR1. Sarah, Pan\nR2. Sarah, Jeff\nR3. Sarah, Pan, Jeff\n\nAssume we have a Patent Table, which has 1 record\nP1. Pan, Jeff\n\nFrom this method, it looks like Pan from R1 and Pan from P1 are the same Pan, and Jeff from R2 and Jeff from P1 are the same Jeff, because they both worked with a \"Sarah\", but with the current workflow, they would not be disambiguated. Only R3's Pan and Jeff would be disambiguated.\n\nI think this could be a starting point of one of the things to work on for the future.\n",
    "created" : 1517440076209.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "306645097",
    "id" : "28DF047",
    "lastKnownWriteTime" : 1517441878,
    "last_content_update" : 1517441878114,
    "path" : "~/Library/Mobile Documents/com~apple~CloudDocs/iSchool Classes/Genbank/week 12 documentation.Rmd",
    "project_path" : "week 12 documentation.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}